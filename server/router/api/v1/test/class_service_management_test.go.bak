package test

import (
	"context"
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"


	apiv1 "github.com/usememos/memos/proto/gen/api/v1"
)

func TestAddClassMember(t *testing.T) {
	ctx := context.Background()

	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create admin user (teacher)
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	require.NotNil(t, teacherUser)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	// Create a class as teacher
	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-member",
			DisplayName: "Test Class for Member",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)
	require.NotNil(t, createdClass)

	// Create a regular user to add as member
	studentUser, err := ts.CreateRegularUser(ctx, "student")
	require.NoError(t, err)
	require.NotNil(t, studentUser)

	// Test 1: Add student as member (success)
	classMember, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.NoError(t, err)
	require.NotNil(t, classMember)
	require.Equal(t, createdClass.GetName(), classMember.GetClass())
	require.Equal(t, fmt.Sprintf("users/%d", studentUser.ID), classMember.GetUser())
	require.Equal(t, apiv1.ClassMemberRole_STUDENT, classMember.GetRole())
	require.True(t, strings.HasPrefix(classMember.GetName(), "classes/"))
	require.True(t, strings.Contains(classMember.GetName(), "/members/"))

	// Test 2: Add duplicate member (should fail)
	_, err = ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_ASSISTANT,
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "already a member")

	// Test 3: Regular user trying to add member (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	require.NotNil(t, regularUser)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.AddClassMember(regularCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")

	// Test 4: Add with different roles
	anotherUser, err := ts.CreateRegularUser(ctx, "another")
	require.NoError(t, err)
	require.NotNil(t, anotherUser)

	// Try adding with different roles
	for _, role := range []apiv1.ClassMemberRole{
		apiv1.ClassMemberRole_TEACHER,
		apiv1.ClassMemberRole_ASSISTANT,
		apiv1.ClassMemberRole_PARENT,
	} {
		// Use different user for each role attempt
		testUser, err := ts.CreateRegularUser(ctx, fmt.Sprintf("user-for-role-%d", role))
		require.NoError(t, err)
		
		classMember, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
			Class: createdClass.GetName(),
			User:  fmt.Sprintf("users/%d", testUser.ID),
			Role:  role,
		})
		require.NoError(t, err)
		require.Equal(t, role, classMember.GetRole())
	}
}

func TestRemoveClassMember(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-remove-member",
			DisplayName: "Test Class for Remove Member",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create and add student
	studentUser, err := ts.CreateRegularUser(ctx, "student")
	require.NoError(t, err)

	// Add member first
	addedMember, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.NoError(t, err)
	require.NotNil(t, addedMember)

	// Test 1: Remove member (success)
	_, err = ts.Service.RemoveClassMember(teacherCtx, &apiv1.RemoveClassMemberRequest{
		Name: addedMember.GetName(),
	})
	require.NoError(t, err)

	// Test 2: Remove non-existent member (should fail)
	_, err = ts.Service.RemoveClassMember(teacherCtx, &apiv1.RemoveClassMemberRequest{
		Name: "classes/999/members/999",
	})
	require.Error(t, err)

	// Test 3: Regular user trying to remove member (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	// Add member again for this test
	addedMember2, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.NoError(t, err)

	_, err = ts.Service.RemoveClassMember(regularCtx, &apiv1.RemoveClassMemberRequest{
		Name: addedMember2.GetName(),
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")

	// Test 4: Remove self (student removing themselves, if allowed by policy)
	// This depends on business logic - for now test that teacher can remove
	// Add another student
	anotherStudent, err := ts.CreateRegularUser(ctx, "another-student")
	require.NoError(t, err)
	
	addedMember3, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", anotherStudent.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.NoError(t, err)
	
	// Student tries to remove themselves (may be allowed or not based on policy)
	studentCtx := ts.CreateUserContext(ctx, anotherStudent.ID)
	_, err = ts.Service.RemoveClassMember(studentCtx, &apiv1.RemoveClassMemberRequest{
		Name: addedMember3.GetName(),
	})
	// This might fail with permission denied or succeed depending on implementation
	// We'll just ensure it doesn't panic
	require.NotPanics(t, func() {
		_, _ = ts.Service.RemoveClassMember(studentCtx, &apiv1.RemoveClassMemberRequest{
			Name: addedMember3.GetName(),
		})
	})
}

func TestListClassMembers(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-list-members",
			DisplayName: "Test Class for List Members",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Add multiple members with different roles
	membersToAdd := []struct {
		username string
		role     apiv1.ClassMemberRole
	}{
		{"student1", apiv1.ClassMemberRole_STUDENT},
		{"student2", apiv1.ClassMemberRole_STUDENT},
		{"assistant1", apiv1.ClassMemberRole_ASSISTANT},
		{"parent1", apiv1.ClassMemberRole_PARENT},
		{"teacher2", apiv1.ClassMemberRole_TEACHER},
	}

	for _, m := range membersToAdd {
		user, err := ts.CreateRegularUser(ctx, m.username)
		require.NoError(t, err)
		
		_, err = ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
			Class: createdClass.GetName(),
			User:  fmt.Sprintf("users/%d", user.ID),
			Role:  m.role,
		})
		require.NoError(t, err)
	}

	// Test 1: List all members (default)
	listResp, err := ts.Service.ListClassMembers(teacherCtx, &apiv1.ListClassMembersRequest{
		Class: createdClass.GetName(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp)
	// Should have 5 added members (creator is not in class_member table)
	require.Len(t, listResp.GetMembers(), 5)
	
	// Verify creator is NOT in the list (since creator is not in class_member table)
	foundCreator := false
	for _, member := range listResp.GetMembers() {
		if member.GetUser() == fmt.Sprintf("users/%d", teacherUser.ID) {
			foundCreator = true
		}
	}
	require.False(t, foundCreator, "Creator should not be in member list as it's not in class_member table")

	// Test 2: Pagination - limit to 3 members
	listResp2, err := ts.Service.ListClassMembers(teacherCtx, &apiv1.ListClassMembersRequest{
		Class: createdClass.GetName(),
		PageSize: 3,
	})
	require.NoError(t, err)
	require.NotNil(t, listResp2)
	require.Len(t, listResp2.GetMembers(), 3)
	require.NotEmpty(t, listResp2.GetNextPageToken(), "Should have next page token when results exceed page size")

	// Test 3: Use page token (page 1 has 3 members, page 2 should have 2 members)
	listResp3, err := ts.Service.ListClassMembers(teacherCtx, &apiv1.ListClassMembersRequest{
		Class: createdClass.GetName(),
		PageSize:  3,
		PageToken: listResp2.GetNextPageToken(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp3)
	require.Len(t, listResp3.GetMembers(), 2)

	// Test 4: Filter by role (if API supports it - currently not, but test basic listing)
	// For now just verify all members are returned
	
	// Test 5: Regular user trying to list members (should fail if not member)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	// This may succeed or fail depending on class visibility policy
	// We'll just ensure no panic
	require.NotPanics(t, func() {
		_, _ = ts.Service.ListClassMembers(regularCtx, &apiv1.ListClassMembersRequest{
			Class: createdClass.GetName(),
		})
	})
	
	// Test 6: List members of non-existent class (should fail)
	_, err = ts.Service.ListClassMembers(teacherCtx, &apiv1.ListClassMembersRequest{
		Class: "classes/999999999",
	})
	require.Error(t, err)
}

func TestUpdateClassMemberRole(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-update-role",
			DisplayName: "Test Class for Update Role",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create and add student
	studentUser, err := ts.CreateRegularUser(ctx, "student")
	require.NoError(t, err)

	// Add member as student
	addedMember, err := ts.Service.AddClassMember(teacherCtx, &apiv1.AddClassMemberRequest{
		Class: createdClass.GetName(),
		User:  fmt.Sprintf("users/%d", studentUser.ID),
		Role:  apiv1.ClassMemberRole_STUDENT,
	})
	require.NoError(t, err)
	require.NotNil(t, addedMember)

	// Test 1: Update role from STUDENT to ASSISTANT (success)
	updatedMember, err := ts.Service.UpdateClassMemberRole(teacherCtx, &apiv1.UpdateClassMemberRoleRequest{
		Name: addedMember.GetName(),
		Role: apiv1.ClassMemberRole_ASSISTANT,
	})
	require.NoError(t, err)
	require.NotNil(t, updatedMember)
	require.Equal(t, apiv1.ClassMemberRole_ASSISTANT, updatedMember.GetRole())
	require.Equal(t, addedMember.GetName(), updatedMember.GetName())
	require.Equal(t, addedMember.GetClass(), updatedMember.GetClass())
	require.Equal(t, addedMember.GetUser(), updatedMember.GetUser())

	// Test 2: Update role to TEACHER (success)
	updatedMember2, err := ts.Service.UpdateClassMemberRole(teacherCtx, &apiv1.UpdateClassMemberRoleRequest{
		Name: addedMember.GetName(),
		Role: apiv1.ClassMemberRole_TEACHER,
	})
	require.NoError(t, err)
	require.Equal(t, apiv1.ClassMemberRole_TEACHER, updatedMember2.GetRole())

	// Test 3: Update non-existent member (should fail)
	_, err = ts.Service.UpdateClassMemberRole(teacherCtx, &apiv1.UpdateClassMemberRoleRequest{
		Name: "classes/999/members/999",
		Role: apiv1.ClassMemberRole_STUDENT,
	})
	require.Error(t, err)

	// Test 4: Regular user trying to update role (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.UpdateClassMemberRole(regularCtx, &apiv1.UpdateClassMemberRoleRequest{
		Name: addedMember.GetName(),
		Role: apiv1.ClassMemberRole_STUDENT,
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")

	// Test 5: Update to same role (should succeed but no change)
	// First ensure current role is TEACHER
	require.Equal(t, apiv1.ClassMemberRole_TEACHER, updatedMember2.GetRole())
	updatedMember3, err := ts.Service.UpdateClassMemberRole(teacherCtx, &apiv1.UpdateClassMemberRoleRequest{
		Name: addedMember.GetName(),
		Role: apiv1.ClassMemberRole_TEACHER,
	})
	require.NoError(t, err)
	require.Equal(t, apiv1.ClassMemberRole_TEACHER, updatedMember3.GetRole())
}

func TestSetClassMemoVisibility(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-memo-visibility",
			DisplayName: "Test Class for Memo Visibility",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create a memo
	memo, err := ts.CreateMemo(ctx, teacherUser.ID, "Test memo content for visibility")
	require.NoError(t, err)

	// Test 1: Set visibility (success)
	visibility, err := ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  fmt.Sprintf("memos/%d", memo.ID),
		Visibility: apiv1.ClassVisibility_CLASS_PUBLIC,
	})
	require.NoError(t, err)
	require.NotNil(t, visibility)
	require.Equal(t, createdClass.GetName(), visibility.GetClass())
	require.Equal(t, fmt.Sprintf("memos/%d", memo.ID), visibility.GetMemo())
	require.Equal(t, apiv1.ClassVisibility_CLASS_PUBLIC, visibility.GetVisibility())

	// Test 2: Update visibility (change to hidden)
	visibility2, err := ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  fmt.Sprintf("memos/%d", memo.ID),
		Visibility: apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN,
	})
	require.NoError(t, err)
	require.Equal(t, apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN, visibility2.GetVisibility())

	// Test 3: Set visibility for non-existent memo (should fail)
	_, err = ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  "memos/999999",
		Visibility: apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE,
	})
	require.Error(t, err)

	// Test 4: Regular user trying to set visibility (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.SetClassMemoVisibility(regularCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  fmt.Sprintf("memos/%d", memo.ID),
		Visibility: apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE,
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")
}

func TestGetClassMemoVisibility(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-get-memo-visibility",
			DisplayName: "Test Class for Get Memo Visibility",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create a memo
	memo, err := ts.CreateMemo(ctx, teacherUser.ID, "Test memo content for get visibility")
	require.NoError(t, err)

	// First set visibility
	visibility, err := ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  fmt.Sprintf("memos/%d", memo.ID),
		Visibility: apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE,
	})
	require.NoError(t, err)
	require.NotNil(t, visibility)

	// Test 1: Get visibility (success)
	gotVisibility, err := ts.Service.GetClassMemoVisibility(teacherCtx, &apiv1.GetClassMemoVisibilityRequest{
		Name: visibility.GetName(),
	})
	require.NoError(t, err)
	require.NotNil(t, gotVisibility)
	require.Equal(t, visibility.GetName(), gotVisibility.GetName())
	require.Equal(t, createdClass.GetName(), gotVisibility.GetClass())
	require.Equal(t, fmt.Sprintf("memos/%d", memo.ID), gotVisibility.GetMemo())
	require.Equal(t, apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE, gotVisibility.GetVisibility())

	// Test 2: Get non-existent visibility (should fail)
	_, err = ts.Service.GetClassMemoVisibility(teacherCtx, &apiv1.GetClassMemoVisibilityRequest{
		Name: "classes/999/memoVisibilities/999",
	})
	require.Error(t, err)

	// Test 3: Regular user trying to get visibility (should fail if not member)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	// This may fail with permission denied or succeed depending on implementation
	// We'll just ensure no panic
	require.NotPanics(t, func() {
		_, _ = ts.Service.GetClassMemoVisibility(regularCtx, &apiv1.GetClassMemoVisibilityRequest{
			Name: visibility.GetName(),
		})
	})

	// Test 4: Update visibility and get again
	updatedVisibility, err := ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
		Class: createdClass.GetName(),
		Memo:  fmt.Sprintf("memos/%d", memo.ID),
		Visibility: apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN,
	})
	require.NoError(t, err)

	gotUpdatedVisibility, err := ts.Service.GetClassMemoVisibility(teacherCtx, &apiv1.GetClassMemoVisibilityRequest{
		Name: updatedVisibility.GetName(),
	})
	require.NoError(t, err)
	require.Equal(t, apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN, gotUpdatedVisibility.GetVisibility())
}

func TestListClassMemoVisibilities(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-list-memo-visibilities",
			DisplayName: "Test Class for List Memo Visibilities",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create multiple memos and set visibilities
	memoVisibilities := []struct {
		content    string
		visibility apiv1.ClassMemoVisibility
	}{
		{"Memo 1 content", apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE},
		{"Memo 2 content", apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN},
		{"Memo 3 content", apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE},
		{"Memo 4 content", apiv1.ClassMemoVisibility_CLASS_MEMO_HIDDEN},
		{"Memo 5 content", apiv1.ClassMemoVisibility_CLASS_MEMO_VISIBLE},
	}

	for i, mv := range memoVisibilities {
		memo, err := ts.CreateMemo(ctx, teacherUser.ID, mv.content)
		require.NoError(t, err)

		_, err = ts.Service.SetClassMemoVisibility(teacherCtx, &apiv1.SetClassMemoVisibilityRequest{
			Class: createdClass.GetName(),
			Memo:  fmt.Sprintf("memos/%d", memo.ID),
			Visibility: mv.visibility,
		})
		require.NoError(t, err)
	}

	// Test 1: List all visibilities (default)
	listResp, err := ts.Service.ListClassMemoVisibilities(teacherCtx, &apiv1.ListClassMemoVisibilitiesRequest{
		Class: createdClass.GetName(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp)
	require.Len(t, listResp.GetVisibilities(), 5)

	// Test 2: Pagination - limit to 3 visibilities
	listResp2, err := ts.Service.ListClassMemoVisibilities(teacherCtx, &apiv1.ListClassMemoVisibilitiesRequest{
		Class: createdClass.GetName(),
		PageSize: 3,
	})
	require.NoError(t, err)
	require.NotNil(t, listResp2)
	require.Len(t, listResp2.GetVisibilities(), 3)
	require.NotEmpty(t, listResp2.GetNextPageToken(), "Should have next page token when results exceed page size")

	// Test 3: Use page token (page 1 has 3 visibilities, page 2 should have 2)
	listResp3, err := ts.Service.ListClassMemoVisibilities(teacherCtx, &apiv1.ListClassMemoVisibilitiesRequest{
		Class: createdClass.GetName(),
		PageSize:  3,
		PageToken: listResp2.GetNextPageToken(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp3)
	require.Len(t, listResp3.GetVisibilities(), 2)

	// Test 4: Filter by visibility (if API supports it - currently not, but test basic listing)
	// For now just verify all visibilities are returned

	// Test 5: Regular user trying to list visibilities (should fail if not member)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	// This may succeed or fail depending on class visibility policy
	// We'll just ensure no panic
	require.NotPanics(t, func() {
		_, _ = ts.Service.ListClassMemoVisibilities(regularCtx, &apiv1.ListClassMemoVisibilitiesRequest{
			Class: createdClass.GetName(),
		})
	})

	// Test 6: List visibilities of non-existent class (should fail)
	_, err = ts.Service.ListClassMemoVisibilities(teacherCtx, &apiv1.ListClassMemoVisibilitiesRequest{
		Class: "classes/999999999",
	})
	require.Error(t, err)
}

func TestCreateClassTagTemplate(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-tag-template",
			DisplayName: "Test Class for Tag Template",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Test 1: Create tag template (success)
	tagTemplate, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "tag-template-1",
			DisplayName: "Math Problems",
			Description: "Template for math problems",
			Color:       "#FF5733",
			Tags:        []string{"algebra", "geometry", "calculus"},
		},
	})
	require.NoError(t, err)
	require.NotNil(t, tagTemplate)
	require.Equal(t, createdClass.GetName(), tagTemplate.GetClass())
	require.Equal(t, "tag-template-1", tagTemplate.GetName())
	require.Equal(t, "Math Problems", tagTemplate.GetDisplayName())
	require.Equal(t, "Template for math problems", tagTemplate.GetDescription())
	require.Equal(t, "#FF5733", tagTemplate.GetColor())
	require.ElementsMatch(t, []string{"algebra", "geometry", "calculus"}, tagTemplate.GetTags())
	require.True(t, strings.HasPrefix(tagTemplate.GetName(), "classes/"))
	require.True(t, strings.Contains(tagTemplate.GetName(), "/tagTemplates/"))

	// Test 2: Create duplicate tag template name (should fail)
	_, err = ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "tag-template-1",  // Same name
			DisplayName: "Another Math Template",
			Description: "Another template",
			Color:       "#33FF57",
			Tags:        []string{"trigonometry"},
		},
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "already exists")

	// Test 3: Create with empty tags (should succeed)
	tagTemplate2, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "tag-template-2",
			DisplayName: "Empty Tags Template",
			Description: "Template with no tags",
			Color:       "#3357FF",
			Tags:        []string{},
		},
	})
	require.NoError(t, err)
	require.NotNil(t, tagTemplate2)
	require.Empty(t, tagTemplate2.GetTags())

	// Test 4: Regular user trying to create tag template (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.CreateClassTagTemplate(regularCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "tag-template-3",
			DisplayName: "Unauthorized Template",
			Description: "Should fail",
			Color:       "#FF33A1",
			Tags:        []string{"test"},
		},
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")

	// Test 5: Create in non-existent class (should fail)
	_, err = ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: "classes/999999999",
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "tag-template-4",
			DisplayName: "Non-existent Class Template",
			Description: "Should fail",
			Color:       "#A133FF",
			Tags:        []string{"test"},
		},
	})
	require.Error(t, err)
}

func TestUpdateClassTagTemplate(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-update-tag-template",
			DisplayName: "Test Class for Update Tag Template",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create a tag template first
	tagTemplate, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "original-template",
			DisplayName: "Original Template",
			Description: "Original description",
			Color:       "#FF5733",
			Tags:        []string{"tag1", "tag2"},
		},
	})
	require.NoError(t, err)
	require.NotNil(t, tagTemplate)

	// Test 1: Update tag template (success)
	updatedTagTemplate, err := ts.Service.UpdateClassTagTemplate(teacherCtx, &apiv1.UpdateClassTagTemplateRequest{
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        tagTemplate.GetName(),
			DisplayName: "Updated Template",
			Description: "Updated description",
			Color:       "#33FF57",
			Tags:        []string{"updated-tag1", "updated-tag2", "updated-tag3"},
		},
		UpdateMask: []string{"display_name", "description", "color", "tags"},
	})
	require.NoError(t, err)
	require.NotNil(t, updatedTagTemplate)
	require.Equal(t, "Updated Template", updatedTagTemplate.GetDisplayName())
	require.Equal(t, "Updated description", updatedTagTemplate.GetDescription())
	require.Equal(t, "#33FF57", updatedTagTemplate.GetColor())
	require.ElementsMatch(t, []string{"updated-tag1", "updated-tag2", "updated-tag3"}, updatedTagTemplate.GetTags())
	require.Equal(t, tagTemplate.GetName(), updatedTagTemplate.GetName())
	require.Equal(t, tagTemplate.GetClass(), updatedTagTemplate.GetClass())

	// Test 2: Update non-existent tag template (should fail)
	_, err = ts.Service.UpdateClassTagTemplate(teacherCtx, &apiv1.UpdateClassTagTemplateRequest{
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "classes/999/tagTemplates/999",
			DisplayName: "Non-existent",
			Description: "Should fail",
			Color:       "#000000",
			Tags:        []string{"test"},
		},
		UpdateMask: []string{"display_name"},
	})
	require.Error(t, err)

	// Test 3: Update with partial mask (only display_name)
	updatedPartial, err := ts.Service.UpdateClassTagTemplate(teacherCtx, &apiv1.UpdateClassTagTemplateRequest{
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        tagTemplate.GetName(),
			DisplayName: "Partially Updated",
			Description: "Should not change",  // Not in update_mask
			Color:       "#000000",            // Not in update_mask
			Tags:        []string{"should-not-change"},  // Not in update_mask
		},
		UpdateMask: []string{"display_name"},
	})
	require.NoError(t, err)
	require.Equal(t, "Partially Updated", updatedPartial.GetDisplayName())
	// Description should remain "Updated description" (from previous update)
	require.Equal(t, "Updated description", updatedPartial.GetDescription())
	// Color should remain "#33FF57"
	require.Equal(t, "#33FF57", updatedPartial.GetColor())
	// Tags should remain previous tags
	require.ElementsMatch(t, []string{"updated-tag1", "updated-tag2", "updated-tag3"}, updatedPartial.GetTags())

	// Test 4: Regular user trying to update tag template (should fail)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.UpdateClassTagTemplate(regularCtx, &apiv1.UpdateClassTagTemplateRequest{
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        tagTemplate.GetName(),
			DisplayName: "Unauthorized Update",
			Description: "Should fail",
			Color:       "#FF0000",
			Tags:        []string{"unauthorized"},
		},
		UpdateMask: []string{"display_name"},
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")
}

func TestDeleteClassTagTemplate(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-delete-tag-template",
			DisplayName: "Test Class for Delete Tag Template",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create a tag template first
	tagTemplate, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "template-to-delete",
			DisplayName: "Template to Delete",
			Description: "This will be deleted",
			Color:       "#FF5733",
			Tags:        []string{"tag1", "tag2"},
		},
	})
	require.NoError(t, err)
	require.NotNil(t, tagTemplate)

	// Test 1: Delete tag template (success)
	_, err = ts.Service.DeleteClassTagTemplate(teacherCtx, &apiv1.DeleteClassTagTemplateRequest{
		Name: tagTemplate.GetName(),
	})
	require.NoError(t, err)

	// Verify it's deleted by trying to get it (should fail)
	// Note: There's no GetClassTagTemplate API, so we try to update or delete again
	_, err = ts.Service.DeleteClassTagTemplate(teacherCtx, &apiv1.DeleteClassTagTemplateRequest{
		Name: tagTemplate.GetName(),
	})
	require.Error(t, err)

	// Test 2: Delete non-existent tag template (should fail)
	_, err = ts.Service.DeleteClassTagTemplate(teacherCtx, &apiv1.DeleteClassTagTemplateRequest{
		Name: "classes/999/tagTemplates/999",
	})
	require.Error(t, err)

	// Test 3: Regular user trying to delete tag template (should fail)
	// Create another template
	tagTemplate2, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
		Class: createdClass.GetName(),
		TagTemplate: &apiv1.ClassTagTemplate{
			Name:        "template-to-protect",
			DisplayName: "Template to Protect",
			Description: "Should not be deletable by regular user",
			Color:       "#33FF57",
			Tags:        []string{"protected"},
		},
	})
	require.NoError(t, err)

	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	_, err = ts.Service.DeleteClassTagTemplate(regularCtx, &apiv1.DeleteClassTagTemplateRequest{
		Name: tagTemplate2.GetName(),
	})
	require.Error(t, err)
	require.Contains(t, err.Error(), "permission denied")

	// Test 4: Teacher can still delete after failed regular user attempt
	_, err = ts.Service.DeleteClassTagTemplate(teacherCtx, &apiv1.DeleteClassTagTemplateRequest{
		Name: tagTemplate2.GetName(),
	})
	require.NoError(t, err)
}

func TestListClassTagTemplates(t *testing.T) {
	ctx := context.Background()
	ts := NewTestService(t)
	defer ts.Cleanup()

	// Create teacher and class
	teacherUser, err := ts.CreateHostUser(ctx, "teacher")
	require.NoError(t, err)
	teacherCtx := ts.CreateUserContext(ctx, teacherUser.ID)

	createdClass, err := ts.Service.CreateClass(teacherCtx, &apiv1.CreateClassRequest{
		Class: &apiv1.Class{
			Name:        "test-class-list-tag-templates",
			DisplayName: "Test Class for List Tag Templates",
			Visibility:  apiv1.ClassVisibility_CLASS_PROTECTED,
		},
	})
	require.NoError(t, err)

	// Create multiple tag templates
	tagTemplates := []struct {
		name        string
		displayName string
		description string
		color       string
		tags        []string
	}{
		{"math-template", "Math Problems", "Template for math", "#FF5733", []string{"algebra", "geometry"}},
		{"science-template", "Science Topics", "Template for science", "#33FF57", []string{"physics", "chemistry"}},
		{"english-template", "English Literature", "Template for English", "#3357FF", []string{"poetry", "prose"}},
		{"history-template", "History Events", "Template for history", "#FF33A1", []string{"ancient", "modern"}},
		{"art-template", "Art Topics", "Template for art", "#A133FF", []string{"painting", "sculpture"}},
	}

	for _, tt := range tagTemplates {
		_, err := ts.Service.CreateClassTagTemplate(teacherCtx, &apiv1.CreateClassTagTemplateRequest{
			Class: createdClass.GetName(),
			TagTemplate: &apiv1.ClassTagTemplate{
				Name:        tt.name,
				DisplayName: tt.displayName,
				Description: tt.description,
				Color:       tt.color,
				Tags:        tt.tags,
			},
		})
		require.NoError(t, err)
	}

	// Test 1: List all tag templates (default)
	listResp, err := ts.Service.ListClassTagTemplates(teacherCtx, &apiv1.ListClassTagTemplatesRequest{
		Class: createdClass.GetName(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp)
	require.Len(t, listResp.GetTagTemplates(), 5)

	// Verify all templates are present
	foundNames := make(map[string]bool)
	for _, tt := range listResp.GetTagTemplates() {
		foundNames[tt.GetName()] = true
	}
	for _, tt := range tagTemplates {
		require.True(t, foundNames[tt.name], "Should find template: "+tt.name)
	}

	// Test 2: Pagination - limit to 3 templates
	listResp2, err := ts.Service.ListClassTagTemplates(teacherCtx, &apiv1.ListClassTagTemplatesRequest{
		Class: createdClass.GetName(),
		PageSize: 3,
	})
	require.NoError(t, err)
	require.NotNil(t, listResp2)
	require.Len(t, listResp2.GetTagTemplates(), 3)
	require.NotEmpty(t, listResp2.GetNextPageToken(), "Should have next page token when results exceed page size")

	// Test 3: Use page token (page 1 has 3 templates, page 2 should have 2)
	listResp3, err := ts.Service.ListClassTagTemplates(teacherCtx, &apiv1.ListClassTagTemplatesRequest{
		Class: createdClass.GetName(),
		PageSize:  3,
		PageToken: listResp2.GetNextPageToken(),
	})
	require.NoError(t, err)
	require.NotNil(t, listResp3)
	require.Len(t, listResp3.GetTagTemplates(), 2)

	// Test 4: Regular user trying to list tag templates (should fail if not member)
	regularUser, err := ts.CreateRegularUser(ctx, "regular")
	require.NoError(t, err)
	regularCtx := ts.CreateUserContext(ctx, regularUser.ID)

	// This may succeed or fail depending on class visibility policy
	// We'll just ensure no panic
	require.NotPanics(t, func() {
		_, _ = ts.Service.ListClassTagTemplates(regularCtx, &apiv1.ListClassTagTemplatesRequest{
			Class: createdClass.GetName(),
		})
	})

	// Test 5: List tag templates of non-existent class (should fail)
	_, err = ts.Service.ListClassTagTemplates(teacherCtx, &apiv1.ListClassTagTemplatesRequest{
		Class: "classes/999999999",
	})
	require.Error(t, err)
}
